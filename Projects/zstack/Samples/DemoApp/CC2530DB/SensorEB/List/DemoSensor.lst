###############################################################################
#
# IAR C/C++ Compiler V9.20.1.2476 for 8051                16/Mar/2016  13:27:59
# Copyright 2004-2015 IAR Systems AB.
# Standalone license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\Source\DemoSensor.c
#    Command line       =  
#        -f
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00200000 -DZDAPP_CONFIG_PAN_ID=0x0EAE
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)
#        -DREJOIN_POLL_RATE=440
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\Source\DemoSensor.c
#        -D NWK_AUTO_POLL -D HOLD_AUTO_START -D POWER_SAVING -D NV_INIT -D
#        DEVICE_LOGICAL_TYPE=ZG_DEVICETYPE_ENDDEVICE -lC
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\List\
#        -lA
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\List\
#        --diag_suppress Pe001,Pa010,Pe1665 -o
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\Obj\
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 16 -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\Source\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\ZMain\TI2530DB\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\include\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\hal\target\CC2530EB\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\include\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\high_level\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\mt\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\osal\include\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\saddr\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\services\sdata\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\af\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\nwk\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sapi\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sec\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\sys\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\stack\zdo\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\
#        -I
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\..\..\..\..\..\Components\zmac\f8w\
#        -Oh --require_prototypes
#    List file          =  
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\List\DemoSensor.lst
#    Object file        =  
#        C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\CC2530DB\SensorEB\Obj\DemoSensor.r51
#
###############################################################################

C:\Users\Arnout\Documents\ZigbeeProject\Projects\zstack\Samples\DemoApp\Source\DemoSensor.c
      1          /**************************************************************************************************
      2            Filename:       DemoSensor.c
      3          
      4            Description:    Sensor application for the sensor demo utilizing the Simple API.
      5          
      6                            The sensor node is a ZigBee end device.
      7                            The sensor application binds to a gateway and will periodically
      8                            read temperature and supply voltage from the ADC and send report
      9                            towards the gateway node.
     10          
     11          
     12            Copyright 2009 Texas Instruments Incorporated. All rights reserved.
     13          
     14            IMPORTANT: Your use of this Software is limited to those specific rights
     15            granted under the terms of a software license agreement between the user
     16            who downloaded the software, his/her employer (which must be your employer)
     17            and Texas Instruments Incorporated (the "License").  You may not use this
     18            Software unless you agree to abide by the terms of the License. The License
     19            limits your use, and you acknowledge, that the Software may not be modified,
     20            copied or distributed unless embedded on a Texas Instruments microcontroller
     21            or used solely and exclusively in conjunction with a Texas Instruments radio
     22            frequency transceiver, which is integrated into your product.  Other than for
     23            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     24            works of, modify, distribute, perform, display or sell this Software and/or
     25            its documentation for any purpose.
     26          
     27            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     28            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     29            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     30            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     31            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     32            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     33            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     34            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     35            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     36            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     37            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     38          
     39            Should you have any questions regarding your right to use this Software,
     40            contact Texas Instruments Incorporated at www.TI.com.
     41          **************************************************************************************************/
     42          
     43          /******************************************************************************
     44           * INCLUDES
     45           */
     46          
     47          #include "ZComDef.h"
     48          #include "OSAL.h"
     49          #include "sapi.h"
     50          #include "hal_key.h"
     51          #include "hal_lcd.h"
     52          #include "hal_led.h"
     53          #include "hal_adc.h"
     54          #include "hal_mcu.h"
     55          #include "hal_uart.h"
     56          #include "DemoApp.h"
     57          
     58          /******************************************************************************
     59           * CONSTANTS
     60           */
     61          #define REPORT_FAILURE_LIMIT                4
     62          #define ACK_REQ_INTERVAL                    5 // each 5th packet is sent with ACK request
     63          
     64          // Application States
     65          #define APP_INIT                            0    // Initial state
     66          #define APP_START                           1    // Sensor has joined network
     67          #define APP_BIND                            2    // Sensor is in process of binding
     68          #define APP_REPORT                          4    // Sensor is in reporting state
     69          
     70          // Application osal event identifiers
     71          // Bit mask of events ( from 0x0000 to 0x00FF )
     72          #define MY_START_EVT                        0x0001
     73          #define MY_REPORT_EVT                       0x0002
     74          #define MY_FIND_COLLECTOR_EVT               0x0004
     75          
     76          // ADC definitions for CC2430/CC2530 from the hal_adc.c file
     77          #if defined (HAL_MCU_CC2530)
     78          #define HAL_ADC_REF_125V    0x00    /* Internal 1.25V Reference */
     79          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     80          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     81          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     82          #define HAL_ADC_CHN_VDD3    0x0f    /* Input channel: VDD/3 */
     83          #define HAL_ADC_CHN_TEMP    0x0e    /* Temperature sensor */
     84          #endif // HAL_MCU_CC2530
     85          
     86          /******************************************************************************
     87           * TYPEDEFS
     88           */
     89          
     90          /******************************************************************************
     91           * LOCAL VARIABLES
     92           */
     93          
     94          static uint8 appState =           APP_INIT;
     95          static uint8 reportState =        FALSE;
     96          
     97          static uint8 reportFailureNr =    0;
     98          static uint8  counter =           0;
     99          static uint16 myReportPeriod =    5000;        // milliseconds
    100          static uint16 myBindRetryDelay =  2000;        // milliseconds
    101          static uint8 myStartRetryDelay =    10;        // milliseconds
    102          
    103          static uint16 parentShortAddr;
    104          /*
    105          
    106          output: Door is open/closed
    107          input: Close/open door
    108          #define NUM_OUT_DOOR_COLLECTOR
    109          #define NUM_IN_DOOOR_COLLECTOR
    110          
    111          */
    112          /******************************************************************************
    113           * GLOBAL VARIABLES
    114           */
    115          
    116          // Inputs and Outputs for Sensor device
    117          #define NUM_OUT_CMD_SENSOR                1
    118          #define NUM_IN_CMD_SENSOR                 1
    119          
    120          // List of output and input commands for Sensor device
    121          const cId_t zb_OutCmdList[NUM_OUT_CMD_SENSOR] =
    122          {
    123            DOOR_REPORT_CMD_ID
    124          };
    125          // List of output and input commands for Sensor device
    126          const cId_t zb_InCmdList[NUM_OUT_CMD_SENSOR] =
    127          {
    128            DOOR_REPORT_CMD_ID
    129          };
    130          
    131          // Define SimpleDescriptor for Sensor device
    132          const SimpleDescriptionFormat_t zb_SimpleDesc =
    133          {
    134            MY_ENDPOINT_ID,             //  Endpoint
    135            MY_PROFILE_ID,              //  Profile ID
    136            DEV_ID_SENSOR,              //  Device ID
    137            DEVICE_VERSION_SENSOR,      //  Device Version
    138            0,                          //  Reserved
    139            NUM_IN_CMD_SENSOR,          //  Number of Input Commands
    140            (cId_t *) zb_InCmdList,             //  Input Command List
    141            NUM_OUT_CMD_SENSOR,         //  Number of Output Commands
    142            (cId_t *) zb_OutCmdList     //  Output Command List
    143          };
    144          
    145          /******************************************************************************
    146           * LOCAL FUNCTIONS
    147           */
    148          
    149          void uartRxCB( uint8 port, uint8 event );
    150          static void sendReport(void);
    151          static int8 readTemp(void);
    152          static uint8 readVoltage(void);
    153          
    154          /*****************************************************************************
    155           * @fn          zb_HandleOsalEvent
    156           *
    157           * @brief       The zb_HandleOsalEvent function is called by the operating
    158           *              system when a task event is set
    159           *
    160           * @param       event - Bitmask containing the events that have been set
    161           *
    162           * @return      none
    163           */
    164          void zb_HandleOsalEvent( uint16 event )
    165          {
    166            if( event & SYS_EVENT_MSG )
    167            {
    168            }
    169          
    170            if( event & ZB_ENTRY_EVENT )
    171            {
    172              // blind LED 1 to indicate joining a network
    173              HalLedBlink ( HAL_LED_1, 0, 50, 500 );
    174          
    175              // Start the device
    176              zb_StartRequest();
    177            }
    178          
    179            if ( event & MY_START_EVT )
    180            {
    181              zb_StartRequest();
    182            }
    183          
    184            if ( event & MY_REPORT_EVT )
    185            {
    186              if ( appState == APP_REPORT )
    187              {
    188                static int8 oldValue;
    189                int8 newValue = readTemp();
    190                if(oldValue != newValue || counter == 11){
    191                  sendReport();
    192                  counter = 0;
    193                }
    194                oldValue = newValue;
    195                counter++;
    196                osal_start_timerEx( sapi_TaskID, MY_REPORT_EVT, myReportPeriod );
    197              }
    198            }
    199          
    200            if ( event & MY_FIND_COLLECTOR_EVT )
    201            {
    202              // Delete previous binding
    203              if ( appState == APP_REPORT )
    204              {
    205                zb_BindDevice( FALSE, SENSOR_REPORT_CMD_ID, (uint8 *)NULL );
                                             ^
Error[Pe020]: identifier "SENSOR_REPORT_CMD_ID" is undefined
    206              }
    207          
    208              appState = APP_BIND;
    209              // blink LED 2 to indicate discovery and binding
    210              HalLedBlink ( HAL_LED_2, 0, 50, 500 );
    211          
    212              // Find and bind to a collector device
    213              zb_BindDevice( TRUE, SENSOR_REPORT_CMD_ID, (uint8 *)NULL );
                                          ^
Error[Pe020]: identifier "SENSOR_REPORT_CMD_ID" is undefined
    214            }
    215          }
    216          
    217          /******************************************************************************
    218           * @fn      zb_HandleKeys
    219           *
    220           * @brief   Handles all key events for this device.
    221           *
    222           * @param   shift - true if in shift/alt.
    223           * @param   keys - bit field for key events. Valid entries:
    224           *                 EVAL_SW4
    225           *                 EVAL_SW3
    226           *                 EVAL_SW2
    227           *                 EVAL_SW1
    228           *
    229           * @return  none
    230           */
    231          void zb_HandleKeys( uint8 shift, uint8 keys )
    232          {
    233            // Shift is used to make each button/switch dual purpose.
    234            if ( shift )
    235            {
    236              if ( keys & HAL_KEY_SW_1 )
    237              {
    238              }
    239              if ( keys & HAL_KEY_SW_2 )
    240              {
    241              }
    242              if ( keys & HAL_KEY_SW_3 )
    243              {
    244              }
    245              if ( keys & HAL_KEY_SW_4 )
    246              {
    247              }
    248            }
    249            else
    250            {
    251              if ( keys & HAL_KEY_SW_1 )
    252              {
    253                // Start reporting
    254                if ( reportState == FALSE ) {
    255                  osal_set_event( sapi_TaskID, MY_REPORT_EVT );
    256                  reportState = TRUE;
    257          
    258                  // blink LED 2 to indicate reporting
    259                  HalLedBlink ( HAL_LED_2, 0, 50, 500 );
    260                }
    261              }
    262              if ( keys & HAL_KEY_SW_2 )
    263              {
    264              }
    265              if ( keys & HAL_KEY_SW_3 )
    266              {
    267              }
    268              if ( keys & HAL_KEY_SW_4 )
    269              {
    270              }
    271            }
    272          }
    273          
    274          /******************************************************************************
    275           * @fn          zb_StartConfirm
    276           *
    277           * @brief       The zb_StartConfirm callback is called by the ZigBee stack
    278           *              after a start request operation completes
    279           *
    280           * @param       status - The status of the start operation.  Status of
    281           *                       ZB_SUCCESS indicates the start operation completed
    282           *                       successfully.  Else the status is an error code.
    283           *
    284           * @return      none
    285           */
    286          void zb_StartConfirm( uint8 status )
    287          {
    288            // If the device sucessfully started, change state to running
    289            if ( status == ZB_SUCCESS )
    290            {
    291              // Change application state
    292              appState = APP_START;
    293          
    294              // Set LED 1 to indicate that node is operational on the network
    295              HalLedSet( HAL_LED_1, HAL_LED_MODE_ON );
    296          
    297              // Store parent short address
    298              zb_GetDeviceInfo(ZB_INFO_PARENT_SHORT_ADDR, &parentShortAddr);
    299          
    300              // Set event to bind to a collector
    301              osal_set_event( sapi_TaskID, MY_FIND_COLLECTOR_EVT );
    302            }
    303            else
    304            {
    305              // Try again later with a delay
    306              osal_start_timerEx( sapi_TaskID, MY_START_EVT, myStartRetryDelay );
    307            }
    308          }
    309          
    310          /******************************************************************************
    311           * @fn          zb_SendDataConfirm
    312           *
    313           * @brief       The zb_SendDataConfirm callback function is called by the
    314           *              ZigBee after a send data operation completes
    315           *
    316           * @param       handle - The handle identifying the data transmission.
    317           *              status - The status of the operation.
    318           *
    319           * @return      none
    320           */
    321          void zb_SendDataConfirm( uint8 handle, uint8 status )
    322          {
    323            if(status != ZB_SUCCESS)
    324            {
    325              if ( ++reportFailureNr >= REPORT_FAILURE_LIMIT )
    326              {
    327                 // Stop reporting
    328                 osal_stop_timerEx( sapi_TaskID, MY_REPORT_EVT );
    329          
    330                 // After failure start reporting automatically when the device
    331                 // is binded to a new gateway
    332                 reportState = TRUE;
    333          
    334                 // Try binding to a new gateway
    335                 osal_set_event( sapi_TaskID, MY_FIND_COLLECTOR_EVT );
    336                 reportFailureNr = 0;
    337              }
    338            }
    339            // status == SUCCESS
    340            else
    341            {
    342              // Reset failure counter
    343              reportFailureNr = 0;
    344            }
    345          }
    346          
    347          /******************************************************************************
    348           * @fn          zb_BindConfirm
    349           *
    350           * @brief       The zb_BindConfirm callback is called by the ZigBee stack
    351           *              after a bind operation completes.
    352           *
    353           * @param       commandId - The command ID of the binding being confirmed.
    354           *              status - The status of the bind operation.
    355           *
    356           * @return      none
    357           */
    358          void zb_BindConfirm( uint16 commandId, uint8 status )
    359          {
    360            if( status == ZB_SUCCESS )
    361            {
    362              appState = APP_REPORT;
    363              HalLedSet( HAL_LED_2, HAL_LED_MODE_OFF );
    364          
    365              // After failure reporting start automatically when the device
    366              // is binded to a new gateway
    367              if ( reportState )
    368              {
    369                // blink LED 2 to indicate reporting
    370                HalLedBlink ( HAL_LED_2, 0, 50, 500 );
    371          
    372                // Start reporting
    373                osal_set_event( sapi_TaskID, MY_REPORT_EVT );
    374              }
    375            }
    376            else
    377            {
    378              osal_start_timerEx( sapi_TaskID, MY_FIND_COLLECTOR_EVT, myBindRetryDelay );
    379            }
    380          }
    381          
    382          /******************************************************************************
    383           * @fn          zb_AllowBindConfirm
    384           *
    385           * @brief       Indicates when another device attempted to bind to this device
    386           *
    387           * @param
    388           *
    389           * @return      none
    390           */
    391          void zb_AllowBindConfirm( uint16 source )
    392          {
    393            (void)source;
    394          }
    395          
    396          /******************************************************************************
    397           * @fn          zb_FindDeviceConfirm
    398           *
    399           * @brief       The zb_FindDeviceConfirm callback function is called by the
    400           *              ZigBee stack when a find device operation completes.
    401           *
    402           * @param       searchType - The type of search that was performed.
    403           *              searchKey - Value that the search was executed on.
    404           *              result - The result of the search.
    405           *
    406           * @return      none
    407           */
    408          void zb_FindDeviceConfirm( uint8 searchType, uint8 *searchKey, uint8 *result )
    409          {
    410            (void)searchType;
    411            (void)searchKey;
    412            (void)result;
    413          }
    414          
    415          /******************************************************************************
    416           * @fn          zb_ReceiveDataIndication
    417           *
    418           * @brief       The zb_ReceiveDataIndication callback function is called
    419           *              asynchronously by the ZigBee stack to notify the application
    420           *              when data is received from a peer device.
    421           *
    422           * @param       source - The short address of the peer device that sent the data
    423           *              command - The commandId associated with the data
    424           *              len - The number of bytes in the pData parameter
    425           *              pData - The data sent by the peer device
    426           *
    427           * @return      none
    428           */
    429          void zb_ReceiveDataIndication( uint16 source, uint16 command, uint16 len, uint8 *pData  )
    430          {
    431            (void)source;
    432            (void)command;
    433            (void)len;
    434            (void)pData;
    435          }
    436          
    437          /******************************************************************************
    438           * @fn          uartRxCB
    439           *
    440           * @brief       Callback function for UART
    441           *
    442           * @param       port - UART port
    443           *              event - UART event that caused callback
    444           *
    445           * @return      none
    446           */
    447          void uartRxCB( uint8 port, uint8 event )
    448          {
    449            (void)port;
    450            (void)event;
    451          }
    452          
    453          /******************************************************************************
    454           * @fn          sendReport
    455           *
    456           * @brief       Send sensor report
    457           *
    458           * @param       none
    459           *
    460           * @return      none
    461           */
    462          static void sendReport(void)
    463          {
    464            uint8 pData[SENSOR_REPORT_LENGTH];
    465            static uint8 reportNr = 0;
    466            uint8 txOptions;
    467          
    468            // Read and report temperature value
    469            pData[SENSOR_TEMP_OFFSET] = readTemp();
    470          
    471            // Read and report voltage value
    472            pData[SENSOR_VOLTAGE_OFFSET] = readVoltage();
    473          
    474            pData[SENSOR_PARENT_OFFSET] =  HI_UINT16(parentShortAddr);
    475            pData[SENSOR_PARENT_OFFSET + 1] =  LO_UINT16(parentShortAddr);
    476          
    477            // Set ACK request on each ACK_INTERVAL report
    478            // If a report failed, set ACK request on next report
    479            if ( ++reportNr<ACK_REQ_INTERVAL && reportFailureNr == 0 )
    480            {
    481              txOptions = AF_TX_OPTIONS_NONE;
    482            }
    483            else
    484            {
    485              txOptions = AF_MSG_ACK_REQUEST;
    486              reportNr = 0;
    487            }
    488            // Destination address 0xFFFE: Destination address is sent to previously
    489            // established binding for the commandId.
    490            zb_SendDataRequest( 0xFFFE, SENSOR_REPORT_CMD_ID, SENSOR_REPORT_LENGTH, pData, 0, txOptions, 0 );
                                               ^
Error[Pe020]: identifier "SENSOR_REPORT_CMD_ID" is undefined
    491          }
    492          
    493          /******************************************************************************
    494           * @fn          readTemp
    495           *
    496           * @brief       read temperature from ADC
    497           *
    498           * @param       none
    499           *
    500           * @return      temperature
    501           */
    502          static int8 readTemp(void)
    503          {
    504            static uint16 voltageAtTemp22;
    505            static uint8 bCalibrate = TRUE; // Calibrate the first time the temp sensor is read
    506            uint16 value;
    507            int8 temp;
    508          
    509            #if defined (HAL_MCU_CC2530)
    510            /*
    511             * Use the ADC to read the temperature
    512             */
    513            value = HalReadTemp();
    514          
    515            // Use the 12 MSB of adcValue
    516            value >>= 4;
    517          
    518            /*
    519             * These parameters are typical values and need to be calibrated
    520             * See the datasheet for the appropriate chip for more details
    521             * also, the math below may not be very accurate
    522             */
    523            /* Assume ADC = 1480 at 25C and ADC = 4/C */
    524            #define VOLTAGE_AT_TEMP_25        1480
    525            #define TEMP_COEFFICIENT          4
    526          
    527            // Calibrate for 22C the first time the temp sensor is read.
    528            // This will assume that the demo is started up in temperature of 22C
    529            if ( bCalibrate ) {
    530              voltageAtTemp22 = value;
    531              bCalibrate = FALSE;
    532            }
    533          
    534            temp = 22 + ( (value - voltageAtTemp22) / TEMP_COEFFICIENT );
    535          
    536            // Set 0C as minimum temperature, and 100C as max
    537            if ( temp >= 100 )
    538            {
    539              return 100;
    540            }
    541            else if ( temp <= 0 ) {
    542              return 0;
    543            }
    544            else {
    545              return temp;
    546            }
    547            // Only CC2530 is supported
    548            #else
    549            return 0;
    550            #endif
    551          }
    552          
    553          /******************************************************************************
    554           * @fn          readVoltage
    555           *
    556           * @brief       read voltage from ADC
    557           *
    558           * @param       none
    559           *
    560           * @return      voltage
    561           */
    562          static uint8 readVoltage(void)
    563          {
    564            #if defined (HAL_MCU_CC2530)
    565            /*
    566             * Use the ADC to read the bus voltage
    567             */
    568            uint16 value = HalReadTemp();
    569          
    570            // value now contains measurement of Vdd/3
    571            // 0 indicates 0V and 32767 indicates 1.25V
    572            // voltage = (value*3*1.25)/32767 volts
    573            // we will multiply by this by 10 to allow units of 0.1 volts
    574            value = value >> 6;   // divide first by 2^6
    575            value = (uint16)(value * 37.5);
    576            value = value >> 9;   // ...and later by 2^9...to prevent overflow during multiplication
    577          
    578            return value;
    579            #else
    580            return 0;
    581            #endif // CC2530
    582          }

Errors: 3
Warnings: none
